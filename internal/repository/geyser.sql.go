// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: geyser.sql

package repository

import (
	"context"
	"time"
)

const getGeyserStatus = `-- name: GetGeyserStatus :one
select is_on, action_by, updated_at, ` + "`" + `key` + "`" + `, display_name from geyser_status g join residents r on g.action_by = r.` + "`" + `key` + "`" + `
`

type GetGeyserStatusRow struct {
	IsOn        bool
	ActionBy    string
	UpdatedAt   time.Time
	Key         string
	DisplayName string
}

func (q *Queries) GetGeyserStatus(ctx context.Context) (GetGeyserStatusRow, error) {
	row := q.db.QueryRowContext(ctx, getGeyserStatus)
	var i GetGeyserStatusRow
	err := row.Scan(
		&i.IsOn,
		&i.ActionBy,
		&i.UpdatedAt,
		&i.Key,
		&i.DisplayName,
	)
	return i, err
}

const turnOffGeyser = `-- name: TurnOffGeyser :execrows
update geyser_status set is_on = false where action_by = ? and is_on = true
`

func (q *Queries) TurnOffGeyser(ctx context.Context, userkey string) (int64, error) {
	result, err := q.db.ExecContext(ctx, turnOffGeyser, userkey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const turnOnGeyser = `-- name: TurnOnGeyser :execrows
update geyser_status set is_on = true, action_by = ? where is_on = false
`

func (q *Queries) TurnOnGeyser(ctx context.Context, userkey string) (int64, error) {
	result, err := q.db.ExecContext(ctx, turnOnGeyser, userkey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
